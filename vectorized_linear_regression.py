# -*- coding: utf-8 -*-
"""Vectorized_linear_regression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BuV5zLgqeWlFMeUieO8LCLeHOxhSF8SH
"""

import numpy as np
import pandas as pd
import matplotlib
from matplotlib import pyplot as plt

df=pd.read_csv("/content/sample_data/mnist_train_small.csv")
df.head()

df.describe()

xa=df.drop(["6"],axis=1)
xa.head()

ya=df["6"]
ya.head()

def feature_normalize(X):
    n_features = X.shape[1]
    means = np.array([np.mean(X.iloc[i,:]) for i in range(n_features)])
    stddevs = np.array([np.std(X.iloc[i,:]) for i in range(n_features)])
    normalized = (X - means) / stddevs
    return normalized

X=feature_normalize(xa)

X=np.column_stack((np.ones(len(X)),X))

def compute_cost(X, y, theta,lam):
    return (np.sum(np.square(np.dot(X, theta) - y))+lam*sum(np.square(theta))) / (2 * len(y))

theta = np.zeros(X.shape[1])

def gradient_descent_multi(X, y, theta, alpha,lam, iterations):
    theta = np.zeros(X.shape[1])
    m = len(X)
    cost=[]
    for i in range(iterations):
        gradient = (1/m) * (np.dot(X.T, np.dot(X, theta) - y))
        c=theta[0]
        theta = theta - alpha * (gradient+(1/m)*lam*sum(theta))
        theta[0]=c-alpha*(gradient[0])
        cost.append(compute_cost(X,ya,theta,lam))
    return theta,cost

theta,cost=gradient_descent_multi(X,ya,theta,0.001,0,6000)

n_iterations = [x for x in range(1,6001)]
plt.plot(n_iterations, cost)
plt.xlabel('No. of iterations')
plt.ylabel('Cost')

#IMPORTING TESTSET
dft=pd.read_csv("/content/sample_data/mnist_test.csv")
dft.head()

x_test=dft.drop(["7"],axis=1)
y_test=dft["7"]

x_test=feature_normalize(x_test)

x_test=np.column_stack((np.ones(len(x_test)),x_test))

y_pred=np.dot(x_test,theta)

#DEFINING THRESHOLD FOR ESTIMATING THE PREDICTED_DATA
def threshold(arr,t):
  ypt=[]
  for i in arr:
    if (i-int(i))<=t:
      ypt.append(int(i))
    else:
      ypt.append(int(i)+1)
  return ypt

def accuracy(y_pred_threshold,y):
  count=0
  for i in range(x_test.shape[0]):
    if y_pred_threshold[i]==y[i]:
      count+=1
  return (count/x_test.shape[0])*100

#ACCURACY
def main(y_pred,y,t):
  y_pred_threshold=threshold(y_pred,t)
  return accuracy(y_pred_threshold,y)

main(y_pred,y_test,0.05)

